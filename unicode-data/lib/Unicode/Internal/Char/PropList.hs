-- autogenerated from https://www.unicode.org/Public/15.0.0/ucd/PropList.txt
-- |
-- Module      : Unicode.Internal.Char.PropList
-- Copyright   : (c) 2020 Composewell Technologies and Contributors
-- License     : Apache-2.0
-- Maintainer  : streamly@composewell.com
-- Stability   : experimental

{-# OPTIONS_HADDOCK hide #-}
{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}
{-# HLINT ignore "Use camelCase" #-}

module Unicode.Internal.Char.PropList
    ( isPattern_Syntax
    , isPattern_White_Space
    , isWhite_Space
    ) where

import Data.Char (ord)
import Data.Int (Int8)
import Data.Word (Word8, Word16)
import GHC.Exts (Int#, Char(..), Int(..), Ptr(..), isTrue#, andI#, iShiftL#, iShiftRL#, ord#, (+#), (-#), (<#), (>=#), (<=#))
import Unicode.Internal.Bits (lookupBit#, lookupWord16AsInt#, lookupWord8AsInt#)

{-# INLINE isPattern_Syntax #-}
isPattern_Syntax :: Char -> Bool
isPattern_Syntax = \(C# c) -> let cp = ord# c in isTrue# ((cp >=# 0x0021#) `andI#` (cp <=# 0xFE46#) `andI#` lookupIsPattern_SyntaxBitMap cp)

{-# INLINE lookupIsPattern_SyntaxBitMap #-}
lookupIsPattern_SyntaxBitMap :: Int# -> Int#
lookupIsPattern_SyntaxBitMap n =
    lookupBit# data# (
        lookupWord8AsInt# offsets# (
            n `iShiftRL#` 8#
        ) +# ((n `iShiftRL#` 3#) `andI#` mask)
    ) (n `andI#` 7#)
    where
    mask = (1# `iShiftL#` 5#) -# 1#
    !(Ptr data#) = isPattern_SyntaxDataBitMap
    !(Ptr offsets#) = isPattern_SyntaxOffsetsBitMap

isPattern_SyntaxDataBitMap :: Ptr Int8
isPattern_SyntaxDataBitMap = Ptr
    "\0\0\255\255\255\0\255\127\254\255\239\127\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\254\255\0\252\1\0\
    \\0\120\1\0\0\120\0\0\0\0\254\90\67\136\0\0\128\0\0\0\128\0\14\255\255\255\1\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\
    \\0\0\0\0\192\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\96\0\0\255\255\255\0\255\127\254\255\239\127\0\0\0\0\0\0\0\0\
    \\0\0\0\0\0\0\0\0\0\0\0\0\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\0\0\0\0\0\0\
    \\0\0\0\0\0\0\0\0\0\0\0\0\0\0\255\255\255\255\255\255\255\255\255\255\255\255\255\255\63\0\0\0\240\255\255\255\255\255\255\255\255\255\255\255\255\255"#

isPattern_SyntaxOffsetsBitMap :: Ptr Word8
isPattern_SyntaxOffsetsBitMap = Ptr
    "\40\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\0\144\162\162\182\162\162\214\162\162\162\162\12\12\178\12\72\12\
    \\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\
    \\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\
    \\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\
    \\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\
    \\12\12\12\97\121"#

{-# INLINE isPattern_White_Space #-}
isPattern_White_Space :: Char -> Bool
isPattern_White_Space = \(C# c) -> let cp = ord# c in isTrue# ((cp >=# 0x0009#) `andI#` (cp <=# 0x2029#) `andI#` lookupIsPattern_White_SpaceBitMap cp)

{-# INLINE lookupIsPattern_White_SpaceBitMap #-}
lookupIsPattern_White_SpaceBitMap :: Int# -> Int#
lookupIsPattern_White_SpaceBitMap n =
    lookupBit# data# (
        lookupWord8AsInt# offsets# (
            n `iShiftRL#` 8#
        ) +# ((n `iShiftRL#` 3#) `andI#` mask)
    ) (n `andI#` 7#)
    where
    mask = (1# `iShiftL#` 5#) -# 1#
    !(Ptr data#) = isPattern_White_SpaceDataBitMap
    !(Ptr offsets#) = isPattern_White_SpaceOffsetsBitMap

isPattern_White_SpaceDataBitMap :: Ptr Int8
isPattern_White_SpaceDataBitMap = Ptr
    "\0\62\0\0\1\0\0\0\0\0\0\0\0\0\0\0\32\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\
    \\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\192\0\0\0\3"#

isPattern_White_SpaceOffsetsBitMap :: Ptr Word8
isPattern_White_SpaceOffsetsBitMap = Ptr
    "\0\17\17\17\17\17\17\17\17\17\17\17\17\17\17\17\17\17\17\17\17\17\17\17\17\17\17\17\17\17\17\17\80"#

{-# INLINE isWhite_Space #-}
isWhite_Space :: Char -> Bool
isWhite_Space = \(C# c) -> let cp = ord# c in isTrue# ((cp >=# 0x0009#) `andI#` (cp <=# 0x3000#) `andI#` lookupIsWhite_SpaceBitMap cp)

{-# INLINE lookupIsWhite_SpaceBitMap #-}
lookupIsWhite_SpaceBitMap :: Int# -> Int#
lookupIsWhite_SpaceBitMap n =
    lookupBit# data# (
        lookupWord8AsInt# offsets# (
            n `iShiftRL#` 8#
        ) +# ((n `iShiftRL#` 3#) `andI#` mask)
    ) (n `andI#` 7#)
    where
    mask = (1# `iShiftL#` 5#) -# 1#
    !(Ptr data#) = isWhite_SpaceDataBitMap
    !(Ptr offsets#) = isWhite_SpaceOffsetsBitMap

isWhite_SpaceDataBitMap :: Ptr Int8
isWhite_SpaceDataBitMap = Ptr
    "\255\7\0\0\0\131\0\0\0\0\0\128\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\0\0\
    \\0\0\0\0\0\0\0\0\0\0\0\62\0\0\1\0\0\0\0\0\0\0\0\0\0\0\32\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\
    \\0\0\0\0\0\0\0\0\0\0\0\0\0"#

isWhite_SpaceOffsetsBitMap :: Ptr Word8
isWhite_SpaceOffsetsBitMap = Ptr
    "\60\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\28\12\12\12\12\12\12\12\12\12\0\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\44"#

